inline BranchState::BranchState( RegisterAllocator& allocator ) : m_allocator(allocator)
{
	m_accumulatorFields = 0;
	m_registerFields = 0;

	// initialize constant registers
	writeFloat( 0, 0xf );
	writeInteger( 0 );
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline BranchState::BranchState( const BranchState& a ) : m_allocator(a.m_allocator)
{
	unsigned int i;

	m_current = a.m_current;
	m_exitPoint = a.m_exitPoint;

	m_branches = a.m_branches;

	m_floats = a.m_floats;
	m_integers = a.m_integers;

	m_accumulatorFields = a.m_accumulatorFields;
	m_registerFields = a.m_registerFields;

	for( i = 0; i < 32; i++ )
		m_floatRegisters[i] = a.m_floatRegisters[i];

	for( i = 0; i < 16; i++ )
		m_integerRegisters[i] = a.m_integerRegisters[i];

	m_floatInputs = a.m_floatInputs;
	m_integerInputs = a.m_integerInputs;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline RegisterAllocator& BranchState::allocator() const
{
	return m_allocator;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::setCurrent( std::list<Token>::iterator current )
{
	m_current = current;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline std::list<Token>::iterator BranchState::current() const
{
	return m_current;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::setExitPoint( std::list<Token>::iterator exitPoint )
{
	m_exitPoint = exitPoint;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline std::list<Token>::iterator BranchState::exitPoint() const
{
	return m_exitPoint;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::writeAccumulator( unsigned int fields )
{
	m_accumulatorFields |= fields;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool BranchState::readAccumulator( unsigned int fields ) const
{
	return !(fields & (~m_accumulatorFields));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::writeQ()
{
	m_registerFields |= (1<<Q);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool BranchState::readQ() const
{
	return (m_registerFields & (1<<Q)) != 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::writeP()
{
	m_registerFields |= (1<<P);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool BranchState::readP() const
{
	return (m_registerFields & (1<<P)) != 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::writeR()
{
	m_registerFields |= (1<<R);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool BranchState::readR() const
{
	return (m_registerFields & (1<<R)) != 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::writeI()
{
	m_registerFields |= (1<<I);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool BranchState::readI() const
{
	return (m_registerFields & (1<<I)) != 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline BranchState* BranchState::clone()
{
	return new BranchState( *this );
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline BranchState::State::State()
{
	m_fields = 0;
	m_flags = 0;
	m_dependency = NULL;
	m_isAddress = false;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline BranchState::State::State( const State& a )
{
	m_fields = a.m_fields;
	m_flags = a.m_flags;
	m_dependency = a.m_dependency;
	m_isAddress = a.m_isAddress;
	m_address = a.m_address;
	m_traces = a.m_traces;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline unsigned int BranchState::State::fields() const
{
	return m_fields;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::State::setFields( unsigned int fields )
{
	m_fields = fields;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::State::setFlags( unsigned int flags )
{
	m_flags = flags;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline unsigned int BranchState::State::flags() const
{
	return m_flags;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::State::setDependency( Dependency* dependency )
{
	m_dependency = dependency;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline Dependency* BranchState::State::dependency() const
{
	return m_dependency;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::State::setAddress( std::list<Token>::iterator address )
{
	m_isAddress = true;
	m_address = address;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::State::clearAddress()
{
	m_isAddress = false;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool BranchState::State::isAddress() const
{
	return m_isAddress;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline std::list<Token>::iterator BranchState::State::address() const
{
	assert( m_isAddress );

	return m_address;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::State::pushTrace( Token* location, bool entryPoint )
{
	if( m_traces.empty() && !entryPoint )
	{
		assert( m_dependency );
		m_traces.push_back(Trace(&(m_dependency->token()),true));
	}	

	m_traces.push_back(Trace(location,entryPoint));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline const std::vector<BranchState::State::Trace>& BranchState::State::traces() const
{
	return m_traces;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BranchState::State::clearTrace()
{
	m_traces.clear();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline BranchState::State::Trace::Trace( Token* location, bool entryPoint ) : m_location(location)
{
	m_entryPoint = entryPoint;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline BranchState::State::Trace::Trace( const Trace& t ) : m_location(t.m_location)
{
	m_entryPoint = t.m_entryPoint;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline Token* BranchState::State::Trace::location() const
{
	return m_location;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool BranchState::State::Trace::isEntryPoint() const
{
	return m_entryPoint;
}
